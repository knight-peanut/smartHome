#include "action.h"

int led[7] = {0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x00FFFF, 0x0000FF, 0x8B00FF};
// 智能家居 16*16 小四
unsigned char word1[4][32] = {{0x20,0x00,0x3E,0x7C,0x48,0x44,0x08,0x44,0xFF,0x44,0x14,0x44,0x22,0x7C,0x40,0x00,
0x1F,0xF0,0x10,0x10,0x10,0x10,0x1F,0xF0,0x10,0x10,0x10,0x10,0x1F,0xF0,0x10,0x10}, {0x10,0x40,0x24,0x44,0x42,0x48,0xFF,0x70,0x01,0x40,0x00,0x42,0x7E,0x42,0x42,0x3E,
0x42,0x00,0x7E,0x44,0x42,0x48,0x42,0x70,0x7E,0x40,0x42,0x42,0x4A,0x42,0x44,0x3E}, {0x02,0x00,0x01,0x00,0x7F,0xFE,0x40,0x02,0x80,0x04,0x7F,0xFC,0x02,0x00,0x0D,0x08,
0x71,0x90,0x02,0xA0,0x0C,0xC0,0x71,0xA0,0x06,0x98,0x18,0x86,0xE2,0x80,0x01,0x00}, {0x00,0x00,0x3F,0xF8,0x20,0x08,0x20,0x08,0x3F,0xF8,0x20,0x80,0x20,0x80,0x3F,0xFE,
0x20,0x80,0x20,0x80,0x2F,0xF8,0x28,0x08,0x48,0x08,0x48,0x08,0x8F,0xF8,0x08,0x08}};

// 智慧家居 24*24 小二
unsigned char word2[4][72] = {{0x00,0x00,0x00,0x0E,0x00,0x00,0x0E,0x30,0x08,0x0F,0xFF,0xFC,0x1D,0xC7,0x1C,0x19,
0xC7,0x1C,0x31,0x9F,0x1C,0x7F,0xFF,0x1C,0x23,0x87,0x1C,0x03,0xE7,0x1C,0x07,0x7F,
0xFC,0x07,0x3F,0x1C,0x1E,0x1F,0x78,0x3B,0xFF,0xF0,0x63,0x80,0xE0,0x03,0x80,0xE0,
0x03,0xFF,0xE0,0x03,0x80,0xE0,0x03,0x80,0xE0,0x03,0x80,0xE0,0x03,0xFF,0xE0,0x03,
0x80,0xE0,0x03,0x00,0xE0,0x00,0x00,0x00}, {0x00,0x00,0x00,0x03,0x06,0x00,0x07,0x87,0x00,0x07,0x07,0x30,0x0C,0xE7,0x78,0x18,
0x77,0xF0,0x7F,0xFF,0xCC,0x3F,0xFF,0x0C,0x30,0x77,0x0C,0x3F,0xF7,0x0E,0x38,0x67,
0xFE,0x38,0x60,0x00,0x3F,0xE6,0x00,0x38,0x67,0x38,0x38,0x67,0x7C,0x38,0x67,0xF0,
0x3F,0xE7,0xC0,0x38,0x67,0x0C,0x38,0x67,0x0C,0x38,0x67,0x0E,0x38,0x67,0xFE,0x3B,
0xE7,0xFE,0x38,0xE0,0x00,0x00,0x00,0x00}, {0x00,0x00,0x00,0x00,0x78,0x00,0x00,0x3C,0x00,0x18,0x1C,0x0C,0x1F,0xFF,0xFE,0x18,
0x00,0x1C,0x38,0x00,0xD8,0x3F,0xFF,0xE0,0x00,0x70,0x00,0x00,0xF0,0x60,0x01,0xF0,
0xF0,0x07,0xBB,0xC0,0x1E,0x7F,0x80,0x70,0xEF,0x80,0x03,0xDF,0x80,0x07,0xBF,0xC0,
0x1E,0x7E,0xE0,0x70,0xFE,0x70,0x01,0xCE,0x7C,0x07,0x8E,0x3E,0x1E,0xEE,0x08,0x70,
0x7E,0x00,0x00,0x1C,0x00,0x00,0x00,0x00}, {0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0xFF,0xF8,0x0E,0x00,0x3C,0x0E,0x00,0x38,0x0E,
0x00,0x38,0x0F,0xFF,0xF8,0x0E,0x0C,0x38,0x0E,0x0E,0x00,0x0E,0x0E,0x00,0x0E,0x0E,
0x0C,0x0F,0xFF,0xFE,0x0F,0x0E,0x00,0x0C,0x0E,0x00,0x1C,0x0E,0x30,0x1D,0xFF,0xF8,
0x1D,0xC0,0x70,0x19,0xC0,0x70,0x39,0xC0,0x70,0x39,0xC0,0x70,0x31,0xFF,0xF0,0x61,
0xC0,0x70,0x41,0x80,0x00,0x00,0x00,0x00}};


// 小组成员: 16*16 小四
unsigned char word3[5][32] = {{0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x11,0x10,0x11,0x08,0x11,0x04,
0x21,0x04,0x21,0x02,0x41,0x02,0x81,0x02,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00}, {0x10,0x00,0x11,0xF8,0x21,0x08,0x21,0x08,0x49,0x08,0xF9,0xF8,0x11,0x08,0x21,0x08,
0x41,0x08,0xF9,0xF8,0x41,0x08,0x01,0x08,0x19,0x08,0xE1,0x08,0x47,0xFE,0x00,0x00}, {0x00,0x50,0x00,0x48,0x00,0x40,0x3F,0xFE,0x20,0x40,0x20,0x40,0x20,0x44,0x3E,0x44,
0x22,0x44,0x22,0x28,0x22,0x28,0x22,0x12,0x2A,0x32,0x44,0x4A,0x40,0x86,0x81,0x02}, {0x00,0x00,0x1F,0xF0,0x10,0x10,0x10,0x10,0x1F,0xF0,0x00,0x00,0x3F,0xF8,0x20,0x08,
0x20,0x08,0x21,0x08,0x21,0x08,0x21,0x08,0x02,0xC0,0x04,0x30,0x18,0x08,0xE0,0x04}, {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00}};
// 数字0~9 8*16 小四
unsigned char number[10][16] = {{0x00,0x00,0x00,0x18,0x24,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x24,0x18,0x00,0x00
}, {0x00,0x00,0x00,0x08,0x38,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x08,0x3E,0x00,0x00}, {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x02,0x04,0x08,0x10,0x20,0x42,0x7E,0x00,0x00
}, {0x00,0x00,0x00,0x3C,0x42,0x42,0x02,0x04,0x18,0x04,0x02,0x42,0x42,0x3C,0x00,0x00}, {0x00,0x00,0x00,0x04,0x0C,0x0C,0x14,0x24,0x24,0x44,0x7F,0x04,0x04,0x1F,0x00,0x00
}, {0x00,0x00,0x00,0x7E,0x40,0x40,0x40,0x78,0x44,0x02,0x02,0x42,0x44,0x38,0x00,0x00}, {0x00,0x00,0x00,0x18,0x24,0x40,0x40,0x5C,0x62,0x42,0x42,0x42,0x22,0x1C,0x00,0x00
}, {0x00,0x00,0x00,0x7E,0x42,0x04,0x04,0x08,0x08,0x10,0x10,0x10,0x10,0x10,0x00,0x00
}, {0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x24,0x18,0x24,0x42,0x42,0x42,0x3C,0x00,0x00}, {0x00,0x00,0x00,0x38,0x44,0x42,0x42,0x42,0x46,0x3A,0x02,0x02,0x24,0x18,0x00,0x00}};

// 路人甲 16*16 小四
unsigned char mem1[3][32] = {{0x00,0x40,0x7C,0x40,0x44,0x78,0x44,0x88,0x45,0x50,0x7C,0x20,0x10,0x50,0x10,0x88,
0x11,0x06,0x5C,0xF8,0x50,0x88,0x50,0x88,0x50,0x88,0x5C,0x88,0xE0,0xF8,0x00,0x88
}, {0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x02,0x80,0x02,0x80,
0x04,0x40,0x04,0x40,0x08,0x20,0x08,0x20,0x10,0x10,0x20,0x08,0x40,0x04,0x80,0x02}, {0x00,0x00,0x3F,0xF8,0x21,0x08,0x21,0x08,0x21,0x08,0x3F,0xF8,0x21,0x08,0x21,0x08,
0x21,0x08,0x3F,0xF8,0x21,0x08,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00}};

// 炮灰乙 16*16 小四
unsigned char mem2[3][32] = {{0x10,0x80,0x10,0x80,0x11,0xFC,0x15,0x04,0x5A,0x04,0x55,0xF4,0x51,0x14,0x91,0x14,
0x11,0x14,0x11,0xF4,0x11,0x04,0x29,0x28,0x25,0x12,0x45,0x02,0x40,0xFE,0x80,0x00
}, {0x04,0x00,0x04,0x00,0x04,0x00,0xFF,0xFE,0x08,0x00,0x08,0x80,0x08,0x84,0x12,0x84,
0x12,0x88,0x24,0x90,0x29,0x40,0x41,0x40,0x82,0x20,0x04,0x10,0x18,0x08,0x60,0x06}, {0x00,0x00,0x7F,0xF0,0x00,0x20,0x00,0x40,0x00,0x80,0x01,0x00,0x02,0x00,0x04,0x00,
0x08,0x00,0x10,0x00,0x10,0x00,0x20,0x04,0x20,0x04,0x20,0x04,0x1F,0xFC,0x00,0x00
}};

//  酱油丁 16*16 小四
unsigned char mem3[3][32] = {{0x08,0x40,0x48,0x80,0x29,0xFC,0x1A,0x48,0x28,0x30,0xC9,0xC0,0x08,0x00,0xFF,0xFE,
0x04,0x80,0x3F,0xF8,0x24,0x88,0x28,0x78,0x30,0x08,0x3F,0xF8,0x20,0x08,0x3F,0xF8}, {0x00,0x40,0x20,0x40,0x10,0x40,0x10,0x40,0x87,0xFC,0x44,0x44,0x44,0x44,0x14,0x44,
0x14,0x44,0x27,0xFC,0xE4,0x44,0x24,0x44,0x24,0x44,0x24,0x44,0x27,0xFC,0x04,0x04
}, {0x00,0x00,0x7F,0xFC,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,
0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x05,0x00,0x02,0x00
}};


int fd = -1;
int *addr = NULL;
// 打开LCD
void lcd_open()
{
	// 1.打开帧缓冲设备文件
	int fd = open("/dev/ubuntu_lcd", O_RDWR);
	if(fd == -1)
	{
		perror("open fail");
		exit(1);
	}

	// 2.将打开后的帧缓冲设备文件映射到进程的地址空间中去
	addr = (int *)mmap(NULL, LCD_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if (addr == MAP_FAILED)
	{
		perror("mmap error");
		exit(1);
	}

	printf("lcd open success!!\n");
}

// 刷底色
void drawColor(int color)
{
	int i, j;
	for (i = 0; i < 480; i++)
		for (j = 0; j < 800; j++)
			drawPoint(j, i, color);
}

// 在屏幕上画点
void drawPoint(int x, int y, int color)
{
	// 设定x和y的范围
	if (x < 800 && x >= 0 && y < 480 && y >= 0)
		*(addr + 800 * y + x) = color;
	else
	{
		printf("drawPoint error\n");
		// exit(1);
	}
}

// 显示一个字 任意字体
void displayWord(int x, int y, int bytenum, unsigned char word[], int perlineBit, int color)
{
	int num, byte;
	int cnt = 0;
	for (byte = 0; byte < bytenum; byte++)
	{
		for (num = 7; num >= 0; num--)
		{
			if (word[byte] >> num & 0x01)
			{
				// 画点
				// cnt计数，只取16以内的数作为x坐标 cnt / 2 作为y坐标
				drawPoint(cnt % perlineBit + x, cnt / perlineBit + y, color);
			}
			cnt++;
		}
	}
}

// 显示一组字 小四字体
void displayAllWord1(int x, int y, unsigned char word[][32], int num, int perlineBit, int color)
{
	int i;
	for (i = 0; i < num; i++)
	{
		displayWord(x + perlineBit * i, y, sizeof(word[i]), word[i], perlineBit, color);
	}
}

// 显示一组字 小二字体
void displayAllWord2(int x, int y, unsigned char word[][72], int num, int perlineBit, int color)
{
	int i;
	for (i = 0; i < num; i++)
	{
		displayWord(x + perlineBit * i, y, sizeof(word[i]), word[i], perlineBit, color);
	}
}

// 显示单个成员的姓名和学号 小四字体
void displayMem(int x, int y, int color, char *p, int num, unsigned char mem[][32])
{
	// 显示姓名
	int i;
	for (i = 0; i < num; i++)
	{
		displayWord(x + 16 * i, y, sizeof(mem[i]), mem[i], 16, color);
	}
	// 显示学号
	while (*p != '\0')
	{
		displayWord(x + 48 + 8 * i, y, sizeof(number[(*p - 48)]), number[(*p - 48)], 8, color);
		i++;
		p++;
	}
}

// 显示一组的姓名和学号 小四字体
void displayGroup(int x, int y, int color)
{
	// 显示 ‘小组成员：’
	displayAllWord1(x, y, word3, 5, 16, color);
	displayMem(x, y + 26, color, "12345678901", 3, mem1); // 间隔最小16
	displayMem(x, y + 52, color, "98765432100", 3, mem2);
	displayMem(x, y + 78, color, "52525252525", 3, mem3);
}

// 显示智能家居四个字 小二字体
void displayTitle(int x, int y, int color)
{
	displayAllWord2(x, y, word2, 4, 24, color);
}

// 通过bmp文件头获取图片参数(宽，高，位深)
void getPicPar(int fdBmp, int *width, int *height, unsigned short *bit_per_pix)
{
	lseek(fdBmp, 0x12, SEEK_SET);
	read(fdBmp, width, 4);
	read(fdBmp, height, 4);
	lseek(fdBmp, 0x1c, SEEK_SET);
	read(fdBmp, bit_per_pix, 2);
	// 从0x36开始就是像素数组
	lseek(fdBmp, 0x36, SEEK_SET);
	
}

// 转换位深（bmp文件的24位位深转换为开发板上的32位位深）
void drawBmp(const unsigned char *p, const int pad, const int width, const int height, int x, int y)
{
	int i, j;
	unsigned char r, g, b;
	unsigned int color;
	// 像素是从下到上、从左到右保存的
	for (i = 0; i < height; i++)
	{
		for (j = 0; j < width; j++)
		{
			// 小端模式的存储方式bgr
			b = *(p++);
			g = *(p++);
			r = *(p++);
			color = r << 16 | g << 8 | b;
			// 将转换以后的数据写入到帧缓冲设备文件中去
			drawPoint(j + x, height - 1 - i + y, color);
		}
		// 每次画完一行p就要补成4的倍数
		p += pad;
	}
}

// 显示一张图片
void showPic(const char *path, int x, int y)
{
	// 1.打开图片文件
	int fdBmp = open(path, O_RDWR);
	if(fdBmp == -1)
	{
		perror("open fail");
		exit(1);
	}

	// 2.从图片文件中读取数据到buf所指向的空间（buf所指向的空间是你自己定义的空间）
	// 通过bmp文件头获取长，宽，位深
	int width, height;
	unsigned short bit_per_pix;
	getPicPar(fdBmp, &width, &height, &bit_per_pix);
	// 每一行的字节数
	int bytes_per_line = width * bit_per_pix / 8;
	// 每一行的填充字节数
	int pad = bytes_per_line % 4 == 0 ? 0 : 4 - (bytes_per_line % 4);
	// 为了可移植性可以适当定义大一点(可以定义为常量表达式)
	// 一定要定义成unsigned！！！不然图像会失真
	unsigned char buf[bytes_per_line * height];
	read(fdBmp, buf, bytes_per_line * height);

	// r g b  -> a r g b  将读取到的数据转换成开发板上32位色深的格式
	// 转换位深
	drawBmp(buf, pad, width, height, x, y);

	//	3.关闭文件	
	close(fdBmp);
}

// 关闭LCD
void lcd_close()
{
	int res = munmap(addr, LCD_SIZE);
	if (res == -1)
	{
		perror("munmap error");
		exit(1);
	}
	close(fd);
	printf("lcd closed!!\n");
}

// 获取LCD触摸屏鼠标点击处的位置
void getPos(int *x, int *y)
{
	struct input_event event;
	// 1.打开触摸屏事件文件
	int fdEv = open("/dev/ubuntu_event", O_RDWR);
	if (fdEv < 0)
	{
		perror("open error:\n");
		exit(1);
	}
	int res;
	// 注意while循环的位置，read要重复读取
	while (1)
	{
		res = read(fdEv, &event, sizeof(event));
		if (res != sizeof(event))
		{
			perror("read error:\n");
			exit(1);
		}
		// 3.分析信息
		if (event.type == EV_ABS) // 判断事件类型是不是触摸事件
		{
			if (event.code == ABS_X) // 判断事件代码是不是x坐标
			{
				*x = event.value; // 把事件值给x
			}
			if (event.code == ABS_Y) // 判断事件代码是不y坐标
			{
				*y = event.value; // 把事件值给y
				return ;
			}
		}
	}
	// 5.关闭文件
	close(fdEv);
}

// 设置开关状态
char flag[4] = {'0', '0', '0', '\0'}; // 默认为关

// 显示控件 鼠标控制
void showControl()
{
	// // 默认显示关的图片
	// showPic("./bmps/curtain_off.bmp", 130, 140); // 窗帘
	// showPic("./bmps/door_off.bmp", 350, 140); // 门
	// showPic("./bmps/lamp_off.bmp", 570, 140); // 灯

	
	// 初始化客户端网络
	int sockfd = initNet();

	// 初始化控件状态
	char r[3] = {0};
	int i;
	for (i = 0; i < 3; i++)
	{
		read(sockfd, r, 2); // 连上服务器后服务器就会依次发送窗帘，门，灯的状态过来
		changeStatus(r); // 根据发送的状态信息去改变状态
	}

	// 并发出去读
	pthread_t id;
	int n = pthread_create(&id, NULL, task, (void *)&sockfd);
	if(n != 0)
	{
		perror("create thread fail\n");
	}

	// 根据鼠标的点击情况向服务器发送数据
	int x, y;
	while (1)
	{
		getPos(&x, &y);
		if (x < 130 + 160 && x >= 130 && y < 140 + 200 && y >= 140)
		{
			// write
			char w[3] = {0};
			w[0] = '0'; // 0代表窗帘
			w[1] = flag[0]; // 获取窗帘开关状态
			int num = write(sockfd, w, 2);
			if(num == -1)
			{
				perror("write fail\n");
				exit(1);
			}
		}
		if (x < 350 + 160 && x >= 350 && y < 140 + 200 && y >= 140)
		{
			// write
			char w[3] = {0};
			w[0] = '1'; // 1代表门
			w[1] = flag[1]; // 获取门开关状态
			int num = write(sockfd, w, 2);
			if(num == -1)
			{
				perror("write fail\n");
				exit(1);
			}
		}
		if (x < 570 + 160 && x >= 570 && y < 140 + 200 && y >= 140)
		{
			// write
			char w[3] = {0};
			w[0] = '2'; // 2代表灯
			w[1] = flag[2]; // 获取灯开关状态
			int num = write(sockfd, w, 2);
			if(num == -1)
			{
				perror("write fail\n");
				exit(1);
			}
		}
	}
}

// 初始化客户端网络
int initNet()
{
	//1.socket:
	int sockfd = socket(AF_INET, SOCK_STREAM, 0);
	if(sockfd == -1)
	{
		perror("creat socket fail\n");
		exit(1);
	}

	//2.bind：可要可不要

	//3.connect： 主动与TCP Server建立连接
	//“三次握手”
	struct sockaddr_in a; 

	a.sin_family = AF_INET;
	a.sin_port = htons(10688);
	a.sin_addr.s_addr = inet_addr("112.74.113.206");
	int num = connect(sockfd, (struct sockaddr *)&a,sizeof(struct sockaddr));
	if(num == -1)
	{
		perror("connect fail\n");
		exit(1);
	}
	return sockfd;
}

// 线程并发读取数据，根据读取到的数据去改变开关的状态
void * task(void *ar)
{	
	int sockfd = *(int *)ar;
	//5.read 
	char r[2] = {0};
	while(1)
	{
		int ret = read(sockfd, r, 2);
		if(ret == -1)
		{	
			perror("read sockefd fail\n");
			continue;
		}
		if(ret != 0)
		{
			changeStatus(r);
		}
		
	}
	close(sockfd);
}

// 根据收到的数据更改相应控件的状态
void changeStatus(char *r)
{
	if (r[0] == '0') // 0代表窗帘
	{
		flag[0] = r[1]; // 更新窗帘开关状态
		if (flag[0] == '0')
			showPic("./bmps/curtain_off.bmp", 130, 140); // 窗帘
		else
			showPic("./bmps/curtain_on.bmp", 130, 140); // 窗帘
	}
	else if (r[0] == '1') // 1代表门
	{
		flag[1] = r[1]; // 更新门开关状态
		if (flag[1] == '0')
			showPic("./bmps/door_off.bmp", 350, 140); // 门
		else
			showPic("./bmps/door_on.bmp", 350, 140); // 门
	}
	else if (r[0] == '2') // 2代表灯
	{
		flag[2] = r[1]; // 更新灯开关状态
		if (flag[2] == '0')
			showPic("./bmps/lamp_off.bmp", 570, 140); // 灯
		else
			showPic("./bmps/lamp_on.bmp", 570, 140); // 灯
	}
}